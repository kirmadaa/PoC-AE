name: PoC Automated Vulnerability Remediation

on:
  workflow_dispatch: # Allows manual trigger
  push:
    branches:
      - main
      - master # Adjust if your default branch is different

jobs:
  trivy_scan_and_fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to create branches and push commits
      pull-requests: write # Required to create pull requests
      security-events: write # Required to upload SARIF results

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Needed for creating branches and PRs

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: pip install PyYAML requests # requests for Slack, PyYAML if needed for future YAML manipulation

      - name: Install Trivy
        run: |
          sudo apt-get install wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy

      - name: Build Docker Image (Initial)
        id: build_initial_image
        run: |
          docker build -t go-app-vulnerable:latest ./go-app-vulnerable/
        # working-directory: ./go-app-vulnerable/ # Ensure context is correct
      
      - name: Initial Trivy Scan - All Vulnerability Types
        id: initial_scan
        run: |
          echo "Running comprehensive Trivy scan..."
          docker build -t go-app-vulnerable:latest go-app-vulnerable/ # Build image first
          cd go-app-vulnerable/ # Change directory for subsequent scans
          trivy fs --format json --output ../trivy-go-initial.json go.mod
          trivy config --format json --output ../trivy-dockerfile-initial.json Dockerfile
          trivy image --format json --output ../trivy-image-initial.json go-app-vulnerable:latest
          
          # IMPORTANT: For a proper SARIF upload, you should convert the Trivy JSON outputs
          # into a single SARIF file that actually contains results, not just a dummy.
          # For a PoC, a dummy file can trigger the action, but a real one is better.
          # If Trivy can output SARIF directly, use that.
          # trivy fs --format sarif --output ../trivy-fs-initial.sarif .
          # trivy image --format sarif --output ../trivy-image-initial.sarif go-app-vulnerable:latest
          # (Then combine them if needed, or upload multiple SARIFs)

          # For the purpose of getting THIS ERROR FIXED, we'll keep the dummy,
          # but you should aim to generate real SARIF later.
          echo '{"$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "Trivy"}}, "results": []}]}' > ../trivy-dummy-results.sarif
        continue-on-error: true
     
      - name: Upload Initial Scan SARIF results to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-dummy-results.sarif # This should eventually be a real SARIF file
        if: always() # Run even if previous steps fail

        
      - name: Run Automated Remediation Script (Python)
        id: remediation_script_execution
        # Pass all relevant JSON reports to the script
        run: |
          python ../.github/scripts/remediate_pipeline_poc.py \
            --go-report trivy-go-initial.json \
            --dockerfile-report trivy-dockerfile-initial.json \
            --image-report trivy-image-initial.json # Pass image report to remediation script
        working-directory: ./go-app-vulnerable/ # Run script from app context for easier pathing
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} # Optional
        continue-on-error: true

      - name: Check for changes and Create Pull Request
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Go back to root directory to check git status for the whole repo
          cd ..
          git_status=$(git status --porcelain)
          if [ -z "$git_status" ]; then
            echo "::notice::No changes detected after remediation. No PR needed."
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            echo "::notice::Changes detected. Creating PR..."
            CURRENT_BRANCH="${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" # Get current branch name
            REMEDIATION_BRANCH="autofix/vuln-$(date +%Y%m%d%H%M%S)-${CURRENT_BRANCH}"
            
            git config user.name "GitHub Actions Automation"
            git config user.email "actions@github.com"
            
            git checkout -b "$REMEDIATION_BRANCH"
            git add .
            git commit -m "chore(security): Automated vulnerability remediation by Trivy-PoC"
            git push origin "$REMEDIATION_BRANCH"

            PR_BODY_SUMMARY=$(cat .github/autofix_summary_poc.txt || echo "Automated vulnerability remediation completed.")

            PR_URL=$(gh pr create \
              --base "$CURRENT_BRANCH" \
              --head "$REMEDIATION_BRANCH" \
              --title "feat(security): Automated Go & Docker vulnerability fixes" \
              --body "This PR was automatically generated by the vulnerability-autofix-poc workflow.\n\n### Remediation Summary:\n${PR_BODY_SUMMARY}" \
              --json url -q .url \
              --reviewer ${{ github.actor }} 
            )
            echo "::notice::Pull request created: $PR_URL"
            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Build Docker Image (Post-Remediation)
        id: build_post_remediation_image
        if: steps.create_pr.outputs.changes_made == 'true'
        run: |
          docker build -t go-app-vulnerable:autofix-latest go-app-vulnerable/
        working-directory: ./go-app-vulnerable/
      
      - name: Re-scan after Remediation (for validation)
        id: post_remediation_scan
        if: steps.create_pr.outputs.changes_made == 'true'
        run: |
          echo "Re-scanning the potentially fixed code/image..."
          # Re-scan updated Go module (filesystem)
          trivy fs --format json --output ../trivy-go-recheck.json go.mod
          # Re-scan Dockerfile (config)
          trivy config --format json --output ../trivy-dockerfile-recheck.json Dockerfile
          # Re-scan the NEWLY BUILT Docker Image
          trivy image --format json --output ../trivy-image-recheck.json go-app-vulnerable:autofix-latest
        working-directory: ./go-app-vulnerable/
        continue-on-error: true
        
      - name: Upload Post-Remediation SARIF results to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-dummy-results.sarif # Use actual SARIF converter here
        if: always() && steps.create_pr.outputs.changes_made == 'true'
      # - name: Notify Slack on Remediation Attempt (if Slack configured)
      #   if: success() || failure() # Trigger on success or failure
      #   uses: slackapi/slack-github-action@v1.24.0
      #   with:
      #     slack-message: |
      #       *PoC: Automated Vulnerability Remediation Attempt:*
      #       Repository: ${{ github.repository }}
      #       Branch: `${{ github.ref_name }}`
      #       Workflow: `${{ github.workflow }}`
      #       Status: `${{ job.status }}`
      #       ${{ steps.create_pr.outputs.changes_made == 'true' && format('Pull Request: {0}', steps.create_pr.outputs.pr_url) || 'No changes made / No PR created.' }}
      #       Check workflow run for details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} # Requires this secret
      #     SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
      #   if: success() || failure() && env.SLACK_WEBHOOK_URL # Only run if Slack URL is set
