name: PoC Automated Vulnerability Remediation

on:
  workflow_dispatch: # Allows manual trigger
  push:
    branches:
      - main
      - master # Adjust if your default branch is different

jobs:
  trivy_scan_and_fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to create branches and push commits
      pull-requests: write # Required to create pull requests
      security-events: write # Required to upload SARIF results

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Needed for creating branches and PRs

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: pip install PyYAML requests # requests for Slack, PyYAML if needed for future YAML manipulation

      - name: Install Trivy
        run: |
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb [signed-by=/usr/share/keyrings/trivy.gpg] https://aquasecurity.github.io/trivy-repo/deb generic main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy

      - name: Run Trivy Scan on Go Module and Dockerfile
        id: trivy_scan
        # Scan the Go module first, then the Dockerfile
        run: |
          trivy fs -f json -o trivy-go-results.json go-app-vulnerable/go.mod
          trivy fs -f json -o trivy-dockerfile-results.json go-app-vulnerable/Dockerfile
          # Combine results if desired, or process separately. For PoC, simple separate outputs.
          # For a real pipeline, you'd merge these or iterate over `Results`
          
          # This is a dummy SARIF for demonstration. In reality, convert JSON to SARIF if needed.
          echo '{"$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "Trivy"}}, "results": []}]}' > trivy-dummy-results.sarif

      - name: Upload Trivy SARIF results to GitHub Code Scanning (optional for PoC)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-dummy-results.sarif # Use actual SARIF converter for real results
        if: always()

      - name: Execute Automated Remediation Script
        id: remediation
        run: |
          python .github/scripts/remediate_vulnerabilities_poc.py trivy-go-results.json trivy-dockerfile-results.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} # Uncomment and set if you have Slack

      - name: Check for changes and create Pull Request
        id: create_pr
        run: |
          if git diff --exit-code; then
            echo "::notice::No changes detected after remediation. No PR needed."
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            echo "::notice::Changes detected. Creating PR..."
            BRANCH_NAME="autofix/trivy-$(date +%Y%m%d%H%M%S)"
            git config user.name "GitHub Actions Bot"
            git config user.email "actions@github.com"
            git checkout -b $BRANCH_NAME
            git add .
            git commit -m "chore(security): Automated vulnerability remediation by Trivy-PoC"
            git push origin $BRANCH_NAME
            
            PR_TITLE="feat(security): Automated Go & Docker vulnerability fixes"
            PR_BODY="This PR was automatically generated by the vulnerability-autofix-poc workflow.\n\nIt addresses vulnerabilities reported by Trivy.\n\n### Remediation Summary:\n\n$(cat .github/autofix_summary_poc.txt || echo 'No specific summary generated.')"

            PR_URL=$(gh pr create --base ${{ github.ref_name }} --head $BRANCH_NAME --title "$PR_TITLE" --body "$PR_BODY" --json url -q .url)
            echo "::notice::Pull request created: $PR_URL"
            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true # Allow subsequent steps to run

      - name: Re-scan after potential remediation
        if: steps.create_pr.outputs.changes_made == 'true'
        run: |
          echo "Re-scanning the potentially fixed code/image..."
          trivy fs -f json -o trivy-go-recheck-results.json go-app-vulnerable/go.mod
          trivy fs -f json -o trivy-dockerfile-recheck-results.json go-app-vulnerable/Dockerfile
          echo "Re-scan complete. Check trivy-go-recheck-results.json and trivy-dockerfile-recheck-results.json for updated status."
          # Add logic here to compare reports and update PR if desired
        continue-on-error: true

      # - name: Notify Slack on Remediation Attempt (if Slack configured)
      #   if: success() || failure() # Trigger on success or failure
      #   uses: slackapi/slack-github-action@v1.24.0
      #   with:
      #     slack-message: |
      #       *PoC: Automated Vulnerability Remediation Attempt:*
      #       Repository: ${{ github.repository }}
      #       Branch: `${{ github.ref_name }}`
      #       Workflow: `${{ github.workflow }}`
      #       Status: `${{ job.status }}`
      #       ${{ steps.create_pr.outputs.changes_made == 'true' && format('Pull Request: {0}', steps.create_pr.outputs.pr_url) || 'No changes made / No PR created.' }}
      #       Check workflow run for details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} # Requires this secret
      #     SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
      #   if: success() || failure() && env.SLACK_WEBHOOK_URL # Only run if Slack URL is set
